# プロジェクトルール

## ルールの追加
- 指示された内容は、特に指定がない限り本ファイル（.cursorrules）に追記する
- 追記する際は、関連する既存のセクションに追加するか、新しいセクションを作成する
- 追記後は必ずコミットし、CIの成功を確認する

## プロジェクト概要
- `app`ディレクトリ以下はNext.jsアプリケーション
- App Routerを採用
- TypeScriptとTailwind CSSを使用
- macOS環境を前提とした開発

## Makefileコマンド
- `make init`: プロジェクトの初期化
  - npm installの実行
  - huskyの準備
  - GitHub CLI（gh）のインストール（未インストールの場合）
    - Homebrewを使用してインストール（`brew install gh`）
- `make install`: 依存関係のインストール
- `make dev`: 開発サーバーの起動
- `make build`: プロダクションビルドの実行
- `make test`: テストの実行
- `make lint`: リントの実行
- `make type-check`: 型チェックの実行
- `make clean`: ビルドファイルとキャッシュの削除
- `make help`: 利用可能なコマンドの一覧表示

## Gitルール
- コミットメッセージは Conventional Commits 形式に従う
  - feat: 新機能の追加
  - fix: バグ修正
  - docs: ドキュメントの変更のみ
  - style: コードの意味に影響を与えない変更
  - refactor: バグ修正や機能追加を含まないコードの変更
  - test: テストの追加や既存テストの修正
  - chore: ビルドプロセスやツールの変更
- コミット管理
  - ファイルの変更後は必ずコミットする
  - 作業中は細かくコミットして変更を記録
  - プッシュ前に以下の手順でコミットを整理
    1. `git log`で作業内容を確認
    2. `git rebase -i main`で関連するコミットをまとめる
    3. コミットメッセージを適切に修正
    4. コミットの順序を整理
- 各コミットは単一の責任に焦点を当てる
- 最初のコミットは "first commit" とし、プロジェクトの初期設定を含める
- プッシュ前の確認
  - mainブランチの更新
    1. `git fetch origin main`で最新の情報を取得
    2. `git switch main`でmainブランチに切り替え
    3. `git pull origin main`で最新の変更を取り込む
    4. `git switch -`で作業ブランチに戻る
  - `git diff main`で変更内容を確認
  - 以下の点をチェック
    - 不要なファイルが含まれていないか
    - デバッグコードが残っていないか
    - 機密情報が含まれていないか
    - 意図しない変更が含まれていないか
  - 問題がある場合は適切に対処
    - 不要なファイルは削除またはgitignoreに追加
    - デバッグコードは削除
    - 機密情報は環境変数化
    - 意図しない変更は元に戻す
- Gitフックを使用して品質を担保
  - pre-push: プッシュ前に以下を実行
    - 型チェック
    - リント
    - テスト
    - 差分の確認（対話的に確認を要求）
  - huskyを使用してフックを管理
  - `npm install`時に自動的にフックが設定される

## ブランチ運用とPR
- 新しい作業は必ずブランチを作成して実施
  - ブランチ名は作業内容を表す名前をつける
  - 例: `feature/add-user-auth`, `fix/login-error`
- 作業単位でPRを作成
  - `gh pr create`コマンドを使用
  - PRのタイトルは変更内容を簡潔に表現
  - PRの説明は以下の手順で作成
    1. `.work`ディレクトリを作成（存在しない場合）
    2. 一時的なマークダウンファイルを作成（例: `.work/pr-draft.md`）
    3. `.github/pull_request_template.md`の内容をベースに、PR固有の内容を記載
    4. `gh pr create --body-file`で一時ファイルを使用してPRを作成
    5. PR作成後は一時ファイルを削除
  - PRの説明には以下を含める
    - 概要: PRの目的、背景、変更点を簡潔に記載
    - 変更内容: 具体的な変更内容をリストアップ
    - 確認したこと: 動作確認やテストの内容を記載
    - 補足: レビュアーへの注意点や補足事項を記載
  - PRをマージ可能な状態にする
    1. mainブランチの最新変更を取り込む
       ```bash
       git fetch origin main
       git switch main
       git pull origin main
       git switch -
       git rebase main
       ```
    2. コンフリクトが発生した場合は解消
    3. 変更をプッシュ（必要に応じて`--force-with-lease`を使用）
    4. CIが成功することを確認
    5. レビュー依頼前に以下を確認
       - コミットが整理されているか
       - 不要なファイルが含まれていないか
       - テスト、リント、型チェックが通過しているか
       - コードの品質が確保されているか
- PRは小さく保つ
  - 1つのPRで1つの機能や修正を扱う
  - レビューしやすい規模を維持
- PRのレビュー完了後にマージ
  - すべてのCIチェックが通過していることを確認
  - レビューコメントに対応済みであることを確認
  - コンフリクトが解消されていることを確認

## CI/CD
- GitHub Actionsを使用して以下を自動化
  - 型チェック: TypeScriptの型チェック
  - Lint: ESLintによるコード品質チェック
  - Test: テストの実行
  - Build: プロダクションビルドの確認
- PRのマージ前に全てのチェックが通過していることを確認
- CIの実行結果はPRにコメントとして自動的に追加される
- ワークフローファイルは`.github/workflows`に配置
- Node.jsのバージョンは`.tool-versions`で管理
- ワークフロー確認手順
  1. プッシュ後、`gh run list --workflow="PR Check CI" --limit 1` で状態を確認
  2. `sleep 30` コマンドで30秒待機
  3. 再度 `gh run list` で確認
  4. 失敗時は `gh run view` でログを確認して対応
  5. すべてのチェックがパスするまで2-3を繰り返す
  6. 成功したらPRをマージしてmainブランチを更新
- PRマージ監視手順
  1. `gh pr view $PR_NUMBER --json state -q .state`でPRの状態を確認
  2. 状態が`MERGED`でない場合は、30秒待って再度確認
  3. 状態が`MERGED`になったら以下を実行
     ```bash
     git switch main && git pull origin main
     ```

## Next.jsアプリケーションルール
- App Router規約に従ったファイル配置
  - ページは`app`ディレクトリ以下に配置
  - レイアウトは`layout.tsx`で定義
  - ページは`page.tsx`で定義
  - ルーティングはディレクトリ構造に従う
- コンポーネント設計
  - 再利用可能なコンポーネントは`components`ディレクトリに配置
  - ページ固有のコンポーネントはそのページのディレクトリに配置
  - コンポーネントは適切に型付けする
- スタイリング
  - Tailwind CSSを使用
  - グローバルスタイルは`globals.css`で管理
  - カスタムスタイルは`tailwind.config.ts`で定義
- 状態管理
  - サーバーコンポーネントを優先的に使用
  - クライアントコンポーネントは'use client'ディレクティブを明示
  - 状態管理ライブラリを使用する場合は、プロバイダーを適切に配置
- パフォーマンス
  - 画像は`next/image`を使用
  - リンクは`next/link`を使用
  - 適切なキャッシュ戦略を実装
  - 大きなコンポーネントは必要に応じて動的インポート

## コードスタイル
- 一貫したインデント（タブよりスペースを推奨）
- 1行は120文字以内に収める
- 末尾の空白を削除する
- ファイルの末尾には改行を入れる
- 変数、関数、クラスには意味のある分かりやすい名前を使用する

## プロジェクト構造
- 関連するファイルは近くに配置する
- ディレクトリとファイル名は小文字とハイフンを使用する
- 明確で論理的なディレクトリ構造を維持する
- 設定ファイルはルートディレクトリに配置する
- 一時的なファイルは`.work`ディレクトリに配置
  - PRのドラフト
  - ローカルでの作業メモ
  - その他の一時ファイル
- `.work`ディレクトリは`.gitignore`に追加し、バージョン管理対象外とする

## バージョン管理
- .gitignoreで不要なファイルを除外する
- 依存関係は最新の状態を保つ
- 依存関係のバージョンは固定する

## ドキュメント
- README.mdは常に最新の状態を保つ
- 複雑なロジックや重要な決定事項を文書化する
- README.mdにセットアップ手順を含める
- 環境要件を文書化する

## テスト
- 新機能にはテストを書く
- 既存のテストを維持する
- コミット前にテストを実行する

## コードレビュー
- マージ前にコードレビューを行う
- レビューコメントに対応する
- プルリクエストは焦点を絞り、管理可能なサイズに保つ

## 開発環境
- バージョン管理には.tool-versionsを使用する
- 必要なツールとバージョンを文書化する
- 開発環境のセットアップ手順を最新に保つ
- macOSでの開発を前提とする
  - Homebrewを使用してツールをインストール
  - 必要なツール
    - GitHub CLI（gh）: PRの作成と管理に使用
    - Node.js: アプリケーションの実行環境
    - npm: パッケージ管理に使用
  - インストール手順
    1. Homebrewのインストール（未インストールの場合）
       ```bash
       /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
       ```
    2. `make init`でプロジェクトの初期化を実行
       - GitHub CLI（gh）が自動的にインストールされる
       - npm installが実行される
       - huskyの準備が完了する 